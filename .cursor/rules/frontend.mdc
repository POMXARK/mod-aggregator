---
description: Правила для работы с Svelte 5 frontend компонентами
globs: src/**/*.svelte
---

# Правила для Frontend (Svelte 5)

## Порядок поиска решений

**ВАЖНО: При решении задач сначала ищи в интернете, потом в коде!**

1. Используй web_search для поиска документации и примеров
2. Ищи в открытых проектах на GitHub
3. Анализируй текущий код через codebase_search
4. Только потом пиши код

## Предотвращение зацикливания

**КРИТИЧЕСКИ ВАЖНО: Если один и тот же запрос на исправление выполняется последовательно несколько раз, ОСТАНОВИСЬ!**

- Если пытаешься выполнить одно и то же исправление **более 2 раз подряд** - ОСТАНОВИСЬ
- Если поиск/замена не работает после нескольких попыток - ОСТАНОВИСЬ
- Если получаешь ошибку "string not found" несколько раз - ОСТАНОВИСЬ

**Вместо повторения:**
1. Прочитай файл полностью
2. Проверь текущее состояние через `grep` или `read_file`
3. Попробуй другой подход
4. Сообщи пользователю о проблеме

## Запоминание решений

**Записывай удачные решения в документацию, избегай повторения неудачных!**

- Удачные решения → добавляй в README и комментарии
- Неудачные решения → запоминай и не повторяй без изменений
- Формируй документацию из опыта работы с проектом

## Использование Svelte 5 Runes

### State Management
- Используй `$state()` для реактивного состояния
- Используй `$derived()` для вычисляемых значений
- Используй `$effect()` для побочных эффектов
- НЕ используй старый API с `let` и `$:` для реактивности

### Примеры правильного кода:

```svelte
<script lang="ts">
  let count = $state(0);
  let doubled = $derived(count * 2);
  
  $effect(() => {
    console.log('Count changed:', count);
  });
</script>
```

## Компонентная архитектура

### Структура компонента
1. `<script lang="ts">` - логика и импорты
2. `<template>` - разметка
3. `<style>` - стили (изолированные)

### Props и Events
- Используй `$props()` для получения пропсов
- Используй `$bindable()` для двустороннего связывания
- Используй callback функции для событий

```svelte
<script lang="ts">
  interface Props {
    title: string;
    onUpdate?: (value: string) => void;
  }
  
  let { title, onUpdate }: Props = $props();
</script>
```

## Размер файлов

**КРИТИЧЕСКИ ВАЖНО: Не создавай файлы более 1000 строк!**

- Если компонент > 1000 строк → раздели на несколько компонентов
- Вынеси логику в composables
- Раздели большие функции на несколько функций

## Пошаговый рефакторинг

**КРИТИЧЕСКИ ВАЖНО: При рефакторинге больших файлов всегда работай пошагово!**

### Правило пошагового рефакторинга:
1. **Создай новый компонент/composable/утилиту**
2. **СРАЗУ ЖЕ обнови родительский файл**, заменив старый код на использование нового компонента
3. **Проверь, что всё работает** (нет ошибок линтера, импорты корректны)
4. **Только после этого** переходи к следующему шагу

### Почему это важно:
- Избегаешь ситуации, когда создано много файлов, но родительский не обновлен
- Легче отследить ошибки на каждом шаге
- Можно проверить работоспособность после каждого изменения
- Проще откатить изменения, если что-то пошло не так

### Пример правильного подхода:
```
1. Создаю composable useRecentUrls.ts
2. СРАЗУ обновляю PageViewer.svelte - заменяю функции на composable
3. Проверяю линтер и импорты
4. Создаю composable usePageLoader.ts
5. СРАЗУ обновляю PageViewer.svelte - заменяю loadPage на composable
6. И так далее...
```

### НЕПРАВИЛЬНЫЙ подход (НЕ ДЕЛАЙ ТАК):
```
1. Создаю useRecentUrls.ts
2. Создаю usePageLoader.ts
3. Создаю useSelection.ts
4. Создаю ViewerHeader.svelte
5. Создаю PageIframe.svelte
6. Только потом обновляю PageViewer.svelte
```
**Проблема:** Если что-то пойдет не так, будет сложно понять, на каком шаге произошла ошибка, и все файлы могут быть созданы неправильно.

## Стилизация

### Общие правила:
- Используй Tailwind CSS для утилитарных классов
- Изолируй стили в `<style>` блоке только для уникальных стилей компонента
- Используй CSS переменные для темизации
- Следуй темной теме проекта (#0f172a, #1e293b, #334155)

### Длинные CSS и BEM методология:

**КРИТИЧЕСКИ ВАЖНО: Длинные CSS писать отдельно, использовать глобальные стили с BEM методологией!**

1. **Размер CSS блоков:**
   - Если CSS блок > 100 строк → вынеси в отдельный файл
   - Используй глобальные CSS файлы для переиспользуемых стилей
   - Структура: `src/styles/ComponentName.css`

2. **BEM методология (ОБЯЗАТЕЛЬНО):**
   - Формат: `.block__element--modifier`
   - Примеры:
     ```css
     .viewer-header { } /* Block */
     .viewer-header__button { } /* Element */
     .viewer-header__button--active { } /* Modifier */
     .viewer-header--collapsed { } /* Modifier */
     ```

3. **Импорт глобальных стилей:**
   ```svelte
   <script>
     import '../styles/viewer-header.css';
   </script>
   ```

4. **Пример структуры:**
   ```css
   /* src/styles/viewer-header.css */
   .viewer-header {
     display: flex;
     gap: 0.5rem;
   }
   
   .viewer-header--collapsed {
     min-height: 2.5rem;
   }
   
   .viewer-header__button {
     padding: 0.375rem;
   }
   
   .viewer-header__button--active {
     background: #10b981;
   }
   ```

## Типизация

- ВСЕГДА используй TypeScript
- Типизируй все пропсы, события и состояние
- Используй интерфейсы для сложных объектов
- Избегай `any`, используй `unknown` если тип неизвестен

## Комментарии и документация

- **ВСЕГДА** пиши комментарии на русском языке
- Объясняй сложную логику на русском
- Комментируй неочевидные решения

## Документация функций, методов и классов

**КРИТИЧЕСКИ ВАЖНО: Каждая функция/метод/класс должна иметь doc блок с описанием!**

### Правила документации:
1. **ОБЯЗАТЕЛЬНО** документируй все публичные функции, методы и классы
2. Используй JSDoc для TypeScript/JavaScript функций
3. Описание должно быть на русском языке
4. Указывай параметры с `@param` и их типы
5. Указывай возвращаемое значение с `@returns`
6. Описывай логику работы функции/метода

### Примеры:

```typescript
/**
 * Загружает страницу с учетом кеша и привязки к сайту
 * @param url - URL страницы для загрузки
 * @param forceRefresh - если true, загружает с сервера и создает новую версию
 * @returns Promise с HTML содержимым страницы или null в случае ошибки
 */
async function loadPage(url: string, forceRefresh: boolean = false): Promise<string | null> {
  // ...
}
```

```typescript
/**
 * Composable для управления выделением элементов в iframe
 * 
 * Предоставляет функции для включения/выключения режима выделения
 * и обработки сообщений от скрипта выделения в iframe
 */
export function useSelection(callbacks: SelectionCallbacks = {}) {
  // ...
}
```

```svelte
<script lang="ts">
  /**
   * Обрабатывает загрузку страницы
   * @param forceRefresh - принудительно обновить с сервера
   */
  async function handleLoadPage(forceRefresh: boolean = false) {
    // ...
  }
</script>
```


