---
description: Правила для работы с Rust backend (Tauri)
globs: src-tauri/**/*.rs
---

# Правила для Backend (Rust + Tauri)

## Порядок поиска решений

**ВАЖНО: При решении задач сначала ищи в интернете, потом в коде!**

1. Используй web_search для поиска документации Rust/Tauri
2. Ищи примеры в открытых проектах на GitHub
3. Анализируй текущий код через codebase_search
4. Только потом пиши код

## Предотвращение зацикливания

**КРИТИЧЕСКИ ВАЖНО: Если один и тот же запрос на исправление выполняется последовательно несколько раз, ОСТАНОВИСЬ!**

- Если пытаешься выполнить одно и то же исправление **более 2 раз подряд** - ОСТАНОВИСЬ
- Если поиск/замена не работает после нескольких попыток - ОСТАНОВИСЬ
- Если получаешь ошибку "string not found" несколько раз - ОСТАНОВИСЬ

**Вместо повторения:**
1. Прочитай файл полностью
2. Проверь текущее состояние через `grep` или `read_file`
3. Попробуй другой подход
4. Сообщи пользователю о проблеме

## Запоминание решений

**Записывай удачные решения в документацию, избегай повторения неудачных!**

- Удачные решения → добавляй в README и комментарии
- Неудачные решения → запоминай и не повторяй без изменений
- Формируй документацию из опыта работы с проектом

## Обработка ошибок

- Используй `Result<T, E>` для функций, которые могут вернуть ошибку
- Используй `anyhow::Result` для простых случаев
- Используй `thiserror` для кастомных ошибок
- Всегда обрабатывай ошибки, не используй `unwrap()` в production коде

### Пример:
```rust
pub async fn get_sites() -> Result<Vec<Site>, String> {
    let db = Database::new().await.map_err(|e| e.to_string())?;
    db.get_sites().await.map_err(|e| e.to_string())
}
```

## Tauri Commands

- Все команды должны быть асинхронными
- Используй `#[tauri::command]` макрос
- Возвращай `Result<T, String>` для обработки ошибок на frontend
- Логируй важные операции через `log` crate

## База данных

- Используй SQLx для работы с SQLite
- Всегда используй prepared statements
- Обрабатывай транзакции для множественных операций
- Используй миграции для изменений схемы

## Парсинг

- Используй `scraper` crate для парсинга HTML
- Валидируй селекторы перед использованием
- Обрабатывай случаи, когда элементы не найдены
- Кэшируй результаты парсинга где возможно

## Асинхронность

- Используй `tokio` для async операций
- Используй `spawn` для фоновых задач
- Правильно обрабатывай lifetimes в async контексте

## Комментарии и документация

- **ВСЕГДА** пиши комментарии на русском языке
- Объясняй сложную логику на русском

## Документация функций, методов и классов

**КРИТИЧЕСКИ ВАЖНО: Каждая функция/метод/класс должна иметь doc блок с описанием!**

### Правила документации:
1. **ОБЯЗАТЕЛЬНО** документируй все публичные функции, методы и классы
2. Используй `///` для doc комментариев в Rust
3. Описание должно быть на русском языке
4. Указывай параметры с описанием
5. Указывай возвращаемое значение
6. Описывай логику работы функции/метода

### Примеры:

```rust
/// Получить список всех сайтов из базы данных
/// 
/// # Возвращает
/// Вектор сайтов, отсортированных по имени, или ошибку базы данных
pub async fn get_sites(&self) -> Result<Vec<Site>, sqlx::Error> {
    // ...
}
```

```rust
/// Загружает страницу с сервера или из кеша
/// 
/// # Параметры
/// * `app_handle` - handle приложения Tauri для доступа к файловой системе
/// * `url` - URL страницы для загрузки
/// * `force_refresh` - если true, игнорирует кеш и загружает с сервера
/// * `site_id` - ID сайта для привязки кеша (опционально)
/// 
/// # Возвращает
/// HTML содержимое страницы или ошибку
pub async fn fetch_page(
    app_handle: tauri::AppHandle, 
    url: String, 
    force_refresh: bool, 
    site_id: Option<i64>
) -> Result<String, String> {
    // ...
}
```

```rust
/// Структура для работы с базой данных
/// 
/// Предоставляет методы для работы с сайтами, модами и уведомлениями
pub struct Database {
    pool: SqlitePool,
}
```

## README файлы

- В каждой директории должен быть README.md с описанием архитектуры
- README должен быть на русском языке
- Описывай назначение каждого компонента/модуля


