---
description: Паттерны кода и лучшие практики для проекта
globs: "**/*.{ts,tsx,rs,svelte}"
---

# Паттерны кода и лучшие практики

## Порядок поиска решений

**ВАЖНО: При решении задач всегда следуй этому порядку:**

1. **Сначала ищи в интернете** - используй web_search для поиска:
   - Документации по технологиям (Tauri, Svelte, Rust)
   - Примеров реализации похожих задач
   - Best practices и паттернов проектирования
   - Решений известных проблем

2. **Затем ищи в открытых проектах** - ищи примеры в:
   - GitHub репозиториях с похожим функционалом
   - Open source проектах, решающих похожие задачи
   - Стандартных библиотеках и фреймворках

3. **Потом анализируй текущий код** - используй codebase_search для:
   - Поиска похожих реализаций в проекте
   - Понимания существующих паттернов
   - Проверки связанных компонентов

4. **Только после этого пиши код** - используй найденные решения и адаптируй под проект

## Предотвращение зацикливания

**КРИТИЧЕСКИ ВАЖНО: Если один и тот же запрос на исправление выполняется последовательно несколько раз, ОСТАНОВИСЬ!**

### Правило остановки
- Если ты пытаешься выполнить одно и то же исправление **более 2 раз подряд**
- Если поиск/замена не работает после нескольких попыток
- Если получаешь ошибку "string to replace was not found" несколько раз подряд

**ДЕЙСТВИЯ:**
1. **ОСТАНОВИСЬ** - прекрати повторять одно и то же действие
2. **ПРОАНАЛИЗИРУЙ** - прочитай файл полностью, чтобы понять текущее состояние
3. **ИЗМЕНИ ПОДХОД** - попробуй другой способ решения задачи
4. **ПОПРОСИ ПОМОЩИ** - если не можешь решить, сообщи пользователю о проблеме

### Примеры зацикливания
- ❌ Повторять `search_replace` с одним и тем же `old_string` 3+ раза
- ❌ Пытаться исправить код, который уже исправлен
- ❌ Игнорировать ошибки "string not found" и продолжать попытки

### Правильный подход
- ✅ Прочитать файл полностью перед исправлением
- ✅ Проверить текущее состояние кода через `grep` или `read_file`
- ✅ Использовать другой метод (например, `write` вместо `search_replace`)
- ✅ Сообщить пользователю о проблеме и попросить уточнений

## Запоминание решений

**КРИТИЧЕСКИ ВАЖНО: Запоминай удачные и неудачные решения!**

### Удачные решения
- **Записывай в документацию** - создавай или обновляй README файлы с описанием:
  - Какой подход сработал
  - Почему он был выбран
  - Какие проблемы решил
  - Примеры кода

- **Добавляй комментарии** - документируй в коде:
  - Почему выбрано именно это решение
  - Какие альтернативы были рассмотрены
  - Ссылки на источники (документация, примеры)

### Неудачные решения
- **Избегай повторения ошибок** - если решение не сработало:
  - Записывай почему оно не подошло
  - Указывай какие проблемы возникли
  - Не используй этот подход в будущем без серьезных изменений

- **Анализируй причины** - понимай почему решение не сработало:
  - Технические ограничения
  - Архитектурные проблемы
  - Несовместимость с существующим кодом

### Формирование документации
- **Создавай разделы "Решения"** в README файлах
- **Веди список "Известные проблемы и решения"**
- **Документируй паттерны** которые работают в проекте
- **Обновляй правила** на основе опыта

## Общие принципы

### Именование
- **Файлы**: PascalCase для компонентов (ParserBuilder.svelte), camelCase для утилит (tauri-wrapper.ts)
- **Переменные**: camelCase (selectedSite, currentUrl)
- **Функции**: camelCase с глаголом (handleLoadSite, generateParserCode)
- **Константы**: UPPER_SNAKE_CASE (MAX_RETRIES)
- **Типы/Интерфейсы**: PascalCase (Site, Mod, ParserNode)

### Комментарии и документация
- **ВСЕГДА** пиши комментарии на русском языке
- Используй комментарии для объяснения "почему", а не "что"
- Документируй сложную логику
- Комментируй неочевидные решения

### Документация функций, методов и классов
**КРИТИЧЕСКИ ВАЖНО: Каждая функция/метод/класс должна иметь doc блок с описанием!**

#### Правила документации:
1. **ОБЯЗАТЕЛЬНО** документируй все публичные функции, методы и классы
2. Используй doc блоки (JSDoc для TypeScript/JavaScript, `///` для Rust)
3. Описание должно быть на русском языке
4. Указывай параметры и их типы
5. Указывай возвращаемое значение
6. Описывай логику работы функции/метода

#### TypeScript/JavaScript (JSDoc):
```typescript
/**
 * Загружает страницу с учетом кеша и привязки к сайту
 * @param url - URL страницы для загрузки
 * @param forceRefresh - если true, загружает с сервера и создает новую версию
 * @returns Promise с HTML содержимым страницы или null в случае ошибки
 */
async function loadPage(url: string, forceRefresh: boolean = false): Promise<string | null> {
  // ...
}
```

#### Rust (doc comments):
```rust
/// Загружает страницу с сервера или из кеша
/// 
/// # Параметры
/// * `url` - URL страницы для загрузки
/// * `force_refresh` - если true, игнорирует кеш и загружает с сервера
/// * `site_id` - ID сайта для привязки кеша (опционально)
/// 
/// # Возвращает
/// HTML содержимое страницы или ошибку
pub async fn fetch_page(
    app_handle: tauri::AppHandle, 
    url: String, 
    force_refresh: bool, 
    site_id: Option<i64>
) -> Result<String, String> {
    // ...
}
```

#### Svelte компоненты:
```svelte
<script lang="ts">
  /**
   * Обрабатывает загрузку страницы
   * @param forceRefresh - принудительно обновить с сервера
   */
  async function handleLoadPage(forceRefresh: boolean = false) {
    // ...
  }
</script>
```

```typescript
/**
 * Загружает сайт в PageViewer и создает ноды из конфигурации парсера
 * @param site - объект сайта с конфигурацией парсера
 */
async function handleLoadSite(site: Site) {
  // ...
}
```

```rust
/// Получает список всех сайтов из базы данных
/// Возвращает вектор сайтов или ошибку
pub async fn get_sites() -> Result<Vec<Site>, sqlx::Error> {
    // ...
}
```

## Обработка ошибок

### Frontend (TypeScript/Svelte)
```typescript
try {
  const result = await invoke('get_sites');
  sites = result;
} catch (error) {
  console.error('Failed to load sites:', error);
  error = error instanceof Error ? error.message : 'Ошибка загрузки';
}
```

### Backend (Rust)
```rust
pub async fn get_sites() -> Result<Vec<Site>, String> {
    let db = Database::new().await.map_err(|e| e.to_string())?;
    db.get_sites().await.map_err(|e| e.to_string())
}
```

## Асинхронность

### Frontend
- Используй `async/await` вместо промисов
- Обрабатывай ошибки в try/catch
- Используй `Promise.all()` для параллельных запросов

### Backend
- Используй `async fn` для всех Tauri команд
- Используй `tokio::spawn` для фоновых задач
- Правильно обрабатывай lifetimes

## Состояние компонентов

### Svelte 5 Runes
```svelte
<script lang="ts">
  // Простое состояние
  let count = $state(0);
  
  // Вычисляемое значение
  let doubled = $derived(count * 2);
  
  // Побочный эффект
  $effect(() => {
    console.log('Count:', count);
  });
  
  // Props
  interface Props {
    title: string;
  }
  let { title }: Props = $props();
</script>
```

## Работа с API

### Tauri команды
```typescript
import { invoke } from './lib/tauri-wrapper';

// Вызов команды
const sites = await invoke('get_sites');

// С параметрами
const result = await invoke('add_site', {
  name: 'Site Name',
  url: 'https://example.com',
  parserConfig: {}
});
```

## Валидация данных

- Всегда валидируй входные данные
- Используй TypeScript типы для compile-time проверки
- Добавляй runtime валидацию для пользовательского ввода
- Показывай понятные сообщения об ошибках

## Производительность

- Используй `$derived` вместо пересчета в шаблоне
- Мемоизируй тяжелые вычисления
- Избегай лишних ре-рендеров
- Используй виртуализацию для больших списков

## Размер файлов

**КРИТИЧЕСКИ ВАЖНО: Не создавай файлы более 1000 строк!**

### Правила размера файлов:
- **Максимальный размер файла: 1000 строк**
- Если файл превышает 1000 строк - **ОБЯЗАТЕЛЬНО** раздели его на несколько файлов:
  - Вынеси логику в composables (для Svelte компонентов)
  - Раздели компонент на более мелкие компоненты
  - Вынеси утилиты в отдельные модули
  - Раздели большие функции на несколько функций

### Примеры разделения:
- Компонент > 1000 строк → раздели на несколько компонентов
- Функция > 200 строк → раздели на несколько функций
- Composable > 500 строк → раздели на несколько composables

## Пошаговый рефакторинг

**КРИТИЧЕСКИ ВАЖНО: При рефакторинге больших файлов всегда работай пошагово!**

### Правило пошагового рефакторинга:
1. **Создай новый компонент/composable/утилиту**
2. **СРАЗУ ЖЕ обнови родительский файл**, заменив старый код на использование нового компонента
3. **Проверь, что всё работает** (нет ошибок линтера, импорты корректны)
4. **Только после этого** переходи к следующему шагу

### Почему это важно:
- Избегаешь ситуации, когда создано много файлов, но родительский не обновлен
- Легче отследить ошибки на каждом шаге
- Можно проверить работоспособность после каждого изменения
- Проще откатить изменения, если что-то пошло не так

### Пример правильного подхода:
```
1. Создаю composable useRecentUrls.ts
2. СРАЗУ обновляю PageViewer.svelte - заменяю функции на composable
3. Проверяю линтер и импорты
4. Создаю composable usePageLoader.ts
5. СРАЗУ обновляю PageViewer.svelte - заменяю loadPage на composable
6. И так далее...
```

### НЕПРАВИЛЬНЫЙ подход (НЕ ДЕЛАЙ ТАК):
```
1. Создаю useRecentUrls.ts
2. Создаю usePageLoader.ts
3. Создаю useSelection.ts
4. Создаю ViewerHeader.svelte
5. Создаю PageIframe.svelte
6. Только потом обновляю PageViewer.svelte
```
**Проблема:** Если что-то пойдет не так, будет сложно понять, на каком шаге произошла ошибка, и все файлы могут быть созданы неправильно.

## Стилизация и CSS

**КРИТИЧЕСКИ ВАЖНО: Длинные CSS писать отдельно, использовать глобальные стили с BEM методологией!**

### Правила работы с CSS:

1. **Размер CSS блоков:**
   - Если CSS блок в компоненте > 100 строк → вынеси в отдельный файл
   - Используй глобальные CSS файлы для переиспользуемых стилей
   - Изолированные стили в компонентах только для уникальных стилей

2. **BEM методология:**
   - **Обязательно** используй BEM (Block Element Modifier) для именования классов
   - Формат: `.block__element--modifier`
   - Примеры:
     ```css
     .page-viewer { } /* Block */
     .page-viewer__header { } /* Element */
     .page-viewer__header--collapsed { } /* Modifier */
     .page-viewer__button { } /* Element */
     .page-viewer__button--active { } /* Modifier */
     ```

3. **Структура CSS файлов:**
   - Глобальные стили: `src/styles/` или `src/app.css`
   - Стили компонентов: отдельные файлы `ComponentName.css` или в `<style>` блоке
   - Переиспользуемые стили: глобальные файлы с BEM классами

4. **Примеры правильной структуры:**
   ```css
   /* src/styles/page-viewer.css */
   .page-viewer {
     display: flex;
     flex-direction: column;
   }
   
   .page-viewer__header {
     padding: 0.5rem;
   }
   
   .page-viewer__header--collapsed {
     min-height: 2.5rem;
   }
   
   .page-viewer__button {
     padding: 0.375rem;
   }
   
   .page-viewer__button--active {
     background: #10b981;
   }
   ```

5. **Импорт глобальных стилей:**
   ```svelte
   <!-- В компоненте -->
   <script>
     import '../styles/page-viewer.css';
   </script>
   ```

## Безопасность

- Валидируй все пользовательские данные
- Санитизируй HTML перед отображением
- Используй prepared statements для SQL
- Не доверяй данным от клиента






